#version 330 core
#define MAX_LIGHTS 256

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexColor;
layout(location = 2) in vec3 vertexNormal;

// Output data ; will be interpolated for each fragment.
out vec3 fragmentColor;

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 model_matrix;
uniform mat4 model_rotation_matrix;
uniform vec3 camera_pos;
uniform vec3 camera_look;
uniform int lights_amount;
uniform vec3 light_colors[MAX_LIGHTS];
uniform vec3 light_positions[MAX_LIGHTS];

void main() {
	const float AMBIENT_COEFF = 0.1;
	const float AMBIENT_POWER = 0.2;
	const float DIFFUSION_COEFF = 2.0;
	const float SPECULAR_COEFF = 2.0;
	const float SPECULAR_POWER = 16.0;

	gl_Position =  MVP * vec4(vertexPosition_modelspace, 1);

	vec3 color = vec3(0, 0, 0);
	vec3 real_vert_pos = vec3(model_matrix * vec4(vertexPosition_modelspace, 1));
	vec3 real_normal = normalize(vec3(model_rotation_matrix * vec4(vertexNormal, 1)));
	vec3 real_look = normalize(camera_look);
	for (int light = 0; light < MAX_LIGHTS; ++light) {
		if (light == lights_amount) break;
		vec3 light_direction = normalize(real_vert_pos - light_positions[light]);
		// ambient
		float attenuation_ambient = 1.0f / pow(distance(light_positions[light], real_vert_pos), AMBIENT_POWER);
		float ambient = AMBIENT_COEFF * attenuation_ambient;
		// diffuse
		float attenuation_diffuse = 1.0f / sqrt(distance(light_positions[light], real_vert_pos));
		float diffuse = DIFFUSION_COEFF * attenuation_diffuse * dot(-light_direction, real_normal);
		if (diffuse < 0) diffuse = 0;
		// specular
		float attenuation_specular = 1.0f / sqrt(distance(light_positions[light], real_vert_pos));
		vec3 reflect_direction = reflect(-light_direction, real_normal);
		float specular = max(dot(-real_look, reflect_direction), 0.0);
		if (specular != 0.0) specular = SPECULAR_COEFF * attenuation_specular * pow(specular, SPECULAR_POWER);
		// result
		color += light_colors[light] * (diffuse + specular + ambient);
	}
	color = min(color, 1);
	color = max(color, 0);
	fragmentColor = color * vertexColor;
}
